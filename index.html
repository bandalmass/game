<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‚¬ê°í˜• ë””íœìŠ¤ ê²Œì„</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: white;
            font-family: monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .game-container {
            position: relative;
            border: 2px solid #333;
        }

        #gameCanvas {
            display: block;
            background: #000;
            cursor: none;
        }

        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="600" height="800"></canvas>
    </div>

    <script>
        console.log('ğŸ® ê²Œì„ ì‹œì‘');

        // ìº”ë²„ìŠ¤ ì„¤ì •
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        if (!ctx) {
            console.error('ìº”ë²„ìŠ¤ ì»¨í…ìŠ¤íŠ¸ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
            alert('ë¸Œë¼ìš°ì €ê°€ Canvasë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
        }
        
        // ê²Œì„ ì„¤ì •
        const GRID = 20;
        const COLS = Math.floor(canvas.width / GRID);
        const ROWS = Math.floor(canvas.height / GRID);

        console.log(`ê²Œì„ í•„ë“œ: ${COLS} x ${ROWS}`);

        // í”Œë ˆì´ì–´ (ì´ˆë¡ìƒ‰ 'ã…œ' ëª¨ì–‘)
        const player = {
            x: Math.floor(COLS / 2) - 1,
            y: ROWS - 2,
            width: 3,
            height: 2
        };

        // ê²Œì„ ìš”ì†Œë“¤
        let bullets = [];
        let enemies = [];
        let gameField = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
        // 0: ë¹ˆê³µê°„, 1: í•‘í¬ìƒ‰ ë¸”ë¡, 2: ë…¸ë€ìƒ‰ ë¸”ë¡
        
        // í­ë°œ íŒŒí‹°í´ ë°°ì—´
        let explosionParticles = [];

        // ì ìˆ˜ ì‹œìŠ¤í…œ
        let score = 0;
        let highScore = localStorage.getItem('rectangleDefenseHighScore') || 0;

        // ê²Œì„ ìƒíƒœ ì‹œìŠ¤í…œ
        let gameState = 'start'; // 'start', 'playing', 'gameOver'
        let isGameOver = false;
        const gameOverLineY = player.y - 1; // ìºë¦­í„° í•œ ë¸”ë¡ ìœ„ì— ë¼ì¸

        // í‚¤ë³´ë“œ ìƒíƒœ
        const keys = {};
        const keyPressed = {}; // í‚¤ê°€ ì²˜ìŒ ëˆŒë ¸ëŠ”ì§€ ì¶”ì 
        let leftMoveCounter = 0;
        let rightMoveCounter = 0;
        const MOVE_DELAY = 6; // í•œ ë²ˆ í´ë¦­ì— ë‘ ì¹¸ ì´ë™ ë°©ì§€ë¥¼ ìœ„í•œ ì ë‹¹í•œ ì§€ì—°

        // ìµœê³  ì ìˆ˜ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateHighScore() {
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('rectangleDefenseHighScore', highScore);
                console.log('ğŸ† ì‹ ê¸°ë¡!', highScore, 'ì ');
            }
        }

        // ê²Œì„ ì‹œì‘ í•¨ìˆ˜
        function startGame() {
            gameState = 'playing';
            isGameOver = false;
            score = 0;
            bullets = [];
            enemies = [];
            explosionParticles = [];
            gameField = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
            gameFrame = 0;
            console.log('ğŸ® ê²Œì„ ì‹œì‘!');
        }

        // ê²Œì„ ì¬ì‹œì‘ í•¨ìˆ˜
        function restartGame() {
            gameState = 'playing';
            isGameOver = false;
            score = 0;
            bullets = [];
            enemies = [];
            explosionParticles = [];
            gameField = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
            gameFrame = 0;
            console.log('ğŸ”„ ê²Œì„ ì¬ì‹œì‘!');
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.addEventListener('keydown', (e) => {
            // ì‹œì‘ í™”ë©´ì—ì„œ ìŠ¤í˜ì´ìŠ¤ë°”ë¡œ ê²Œì„ ì‹œì‘
            if (gameState === 'start' && e.key === ' ') {
                startGame();
                e.preventDefault();
                return;
            }
            
            // ê²Œì„ ì˜¤ë²„ ìƒíƒœì—ì„œ Rí‚¤ë¡œ ì¬ì‹œì‘
            if (isGameOver && (e.key === 'r' || e.key === 'R')) {
                restartGame();
                return;
            }
            
            // ê²Œì„ í”Œë ˆì´ ì¤‘ì´ ì•„ë‹ˆë©´ ë‹¤ë¥¸ í‚¤ ì…ë ¥ ë¬´ì‹œ
            if (gameState !== 'playing' || isGameOver) return;
            
            keys[e.key] = true;
            
            // ì²˜ìŒ ëˆŒë ¸ì„ ë•Œë§Œ keyPressed ì„¤ì •
            if (!keyPressed[e.key]) {
                keyPressed[e.key] = true;
                console.log('ğŸ”‘ í‚¤ ëˆŒë¦¼:', e.key);
            }
            
            if (e.key === ' ' || e.key === 'ArrowLeft' || e.key === 'ArrowRight' || 
                e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
            }

            if (e.key === ' ') {
                shoot();
            }
            
            // ë””ë²„ê·¸ í‚¤ (Dí‚¤ë¡œ ê²Œì„ í•„ë“œ ìƒíƒœ í™•ì¸)
            if (e.key === 'd' || e.key === 'D') {
                debugGameField();
                checkIndividualEnemyRectangles(); // ê°•ì œë¡œ ê°œë³„ ì êµ° ì‚¬ê°í˜• ì²´í¬ ì‹¤í–‰
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            keyPressed[e.key] = false;
            
            if (e.key === ' ' || e.key === 'ArrowLeft' || e.key === 'ArrowRight' || 
                e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
            }
        });

        // ì´ì•Œ ë°œì‚¬
        function shoot() {
            const bullet = {
                x: player.x + 1, // ì¤‘ì•™ì—ì„œ ë°œì‚¬
                y: player.y - 1,
                prevY: player.y - 1, // ì´ì „ ìœ„ì¹˜ ì´ˆê¸°í™”
                speed: 1
            };
            bullets.push(bullet);
            console.log('ğŸ’¥ ì´ì•Œ ë°œì‚¬! ìœ„ì¹˜:', bullet.x, bullet.y);
        }

        // í”Œë ˆì´ì–´ ì—…ë°ì´íŠ¸
        function updatePlayer() {
            // ì™¼ìª½ ì´ë™ ì²˜ë¦¬
            if (keys['ArrowLeft']) {
                leftMoveCounter++;
                
                // ì²˜ìŒ ëˆ„ë¥´ë©´ ì¦‰ì‹œ ì´ë™, ì´í›„ ì§€ì—° ê°„ê²©ìœ¼ë¡œ ì´ë™
                if (leftMoveCounter === 1 && player.x > 0) {
                    // ì²« ë²ˆì§¸ ì…ë ¥: ì¦‰ì‹œ ì´ë™
                    player.x--;
                    console.log('â† ì™¼ìª½ ì´ë™ (ì¦‰ì‹œ):', player.x);
                } else if (leftMoveCounter >= MOVE_DELAY && player.x > 0) {
                    // ì—°ì† ì…ë ¥: ì§€ì—° í›„ ì´ë™
                    player.x--;
                    console.log('â† ì™¼ìª½ ì´ë™ (ì—°ì†):', player.x);
                    leftMoveCounter = 1; // 1ë¡œ ë¦¬ì…‹ (0ì´ ì•„ë‹Œ 1ë¡œ í•´ì„œ ì¦‰ì‹œ ì´ë™ ë°©ì§€)
                }
            } else {
                leftMoveCounter = 0; // í‚¤ë¥¼ ë–¼ë©´ ì¦‰ì‹œ ë¦¬ì…‹
            }
            
            // ì˜¤ë¥¸ìª½ ì´ë™ ì²˜ë¦¬
            if (keys['ArrowRight']) {
                rightMoveCounter++;
                
                // ì²˜ìŒ ëˆ„ë¥´ë©´ ì¦‰ì‹œ ì´ë™, ì´í›„ ì§€ì—° ê°„ê²©ìœ¼ë¡œ ì´ë™
                if (rightMoveCounter === 1 && player.x < COLS - player.width) {
                    // ì²« ë²ˆì§¸ ì…ë ¥: ì¦‰ì‹œ ì´ë™
                    player.x++;
                    console.log('â†’ ì˜¤ë¥¸ìª½ ì´ë™ (ì¦‰ì‹œ):', player.x);
                } else if (rightMoveCounter >= MOVE_DELAY && player.x < COLS - player.width) {
                    // ì—°ì† ì…ë ¥: ì§€ì—° í›„ ì´ë™
                    player.x++;
                    console.log('â†’ ì˜¤ë¥¸ìª½ ì´ë™ (ì—°ì†):', player.x);
                    rightMoveCounter = 1; // 1ë¡œ ë¦¬ì…‹ (0ì´ ì•„ë‹Œ 1ë¡œ í•´ì„œ ì¦‰ì‹œ ì´ë™ ë°©ì§€)
                }
            } else {
                rightMoveCounter = 0; // í‚¤ë¥¼ ë–¼ë©´ ì¦‰ì‹œ ë¦¬ì…‹
            }
        }

        // ì´ì•Œ ì—…ë°ì´íŠ¸
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // ì´ì „ ìœ„ì¹˜ ì €ì¥ (ì¶©ëŒ ê°ì§€ìš©)
                bullet.prevY = bullet.y;
                bullet.y -= bullet.speed;
                
                // í™”ë©´ ìœ„ë¡œ ë‚˜ê°€ë©´ ì œê±°
                if (bullet.y < 0) {
                    bullets.splice(i, 1);
                }
            }
        }

        // ì‚¬ê°í˜•ì„ ì™„ì„±í•  ìˆ˜ ìˆëŠ” ì êµ° ë„í˜•ë“¤ë§Œ (ì•„ë˜ì—ì„œ ì´ì•Œë¡œ ì‰½ê²Œ ì±„ìš¸ ìˆ˜ ìˆëŠ” í˜•íƒœ)
        const enemyShapes = [
            // ì™„ì „í•œ ì‚¬ê°í˜•ë“¤
            [[1]],                              // 1x1
            [[1, 1]],                           // 2x1 ê°€ë¡œ
            [[1], [1]],                         // 2x1 ì„¸ë¡œ
            [[1, 1, 1]],                        // 3x1 ê°€ë¡œ
            [[1], [1], [1]],                    // 3x1 ì„¸ë¡œ
            [[1, 1], [1, 1]],                   // 2x2 ì •ì‚¬ê°í˜•
            [[1, 1, 1], [1, 1, 1]],             // 3x2 ì§ì‚¬ê°í˜•
            [[1, 1], [1, 1], [1, 1]],           // 2x3 ì§ì‚¬ê°í˜•
            [[1, 1, 1, 1]],                     // 4x1 ê°€ë¡œ
            [[1], [1], [1], [1]],               // 4x1 ì„¸ë¡œ
            
            // ì•„ë˜ì— êµ¬ë©ì´ ìˆì–´ì„œ ì´ì•Œë¡œ ì‚¬ê°í˜• ì™„ì„± ê°€ëŠ¥ (ã„·ì í˜•íƒœë§Œ)
            [[1, 1, 1], [1, 0, 1]],             // ìœ„ê°€ ë§‰íŒ ã„·ì (ì´ì•Œ 1ê°œë¡œ 2x3 ì™„ì„±)
            [[1, 1, 1, 1], [1, 0, 0, 1]],       // ê¸´ ã„·ì (ì´ì•Œ 2ê°œë¡œ 2x4 ì™„ì„±)
            
            // ê°€ìš´ë° êµ¬ë©ì´ ìˆì–´ì„œ ì´ì•Œë¡œ ì‚¬ê°í˜• ì™„ì„± ê°€ëŠ¥ (ì•„ë˜ìª½ êµ¬ë©ë§Œ)
            [[1, 1, 1], [0, 1, 0]],             // ë’¤ì§‘íŒ Tì (ì´ì•Œ 2ê°œë¡œ 2x3 ì™„ì„±) 
            [[1, 1, 1, 1], [0, 1, 1, 0]],       // í° ë’¤ì§‘íŒ Tì (ì´ì•Œ 2ê°œë¡œ 2x4 ì™„ì„±)
        ];

        // ë‹¨ìˆœí•œ ì êµ° ìƒì„± í•¨ìˆ˜
        function spawnEnemy() {
            const shape = enemyShapes[Math.floor(Math.random() * enemyShapes.length)];
            const shapeWidth = Math.max(...shape.map(row => row.length));
            const MARGIN = 1;
            const minX = MARGIN;
            const maxX = COLS - shapeWidth - MARGIN;
            
            if (maxX < minX) {
                // í™”ë©´ì— ë§ì§€ ì•Šìœ¼ë©´ ë‹¨ì¼ ë¸”ë¡ìœ¼ë¡œ
                const smallShape = [[1]];
                const x = Math.floor(COLS / 2);
                
                const enemy = {
                    x: x,
                    y: -smallShape.length,
                    shape: smallShape,
                    speed: 0.03,
                    fallCounter: 0,
                    attachedBullets: []
                };
                
                enemies.push(enemy);
                console.log('ğŸ“¦ ë‹¨ì¼ ë¸”ë¡ ìƒì„± (í™”ë©´ í¬ê¸° ì œí•œ)');
                return;
            }
            
            const x = Math.floor(Math.random() * (maxX - minX + 1)) + minX;
            
            const enemy = {
                x: x,
                y: -shape.length,
                shape: shape,
                speed: 0.03,
                fallCounter: 0,
                attachedBullets: []
            };
            
            enemies.push(enemy);
            console.log('ğŸ“¦ ì êµ° ìƒì„±!', `${shapeWidth}x${shape.length}`, 'ìœ„ì¹˜:', x);
        }

        // ì  ì—…ë°ì´íŠ¸
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                enemy.fallCounter += enemy.speed;
                if (enemy.fallCounter >= 1) {
                    // ì´ì „ ìœ„ì¹˜ ì €ì¥ (ì¶©ëŒ ê°ì§€ìš©)
                    enemy.prevY = enemy.y;
                    enemy.y++;
                    enemy.fallCounter = 0;
                }
                
                // í™”ë©´ ì•„ë˜ë¡œ ë‚˜ê°€ë©´ ì œê±°
                if (enemy.y > ROWS + 3) {
                    enemies.splice(i, 1);
                }
            }
        }

        // ê°œë³„ ì êµ°ê³¼ ë¶™ì€ ì´ì•Œë“¤ë§Œìœ¼ë¡œ ì‚¬ê°í˜• ì²´í¬
        function checkIndividualEnemyRectangles() {
            let explosionOccurred = false;
            
            // ê° ì êµ°ì— ëŒ€í•´ ê°œë³„ì ìœ¼ë¡œ ì‚¬ê°í˜• ì²´í¬
            for (let enemyIndex = enemies.length - 1; enemyIndex >= 0; enemyIndex--) {
                const enemy = enemies[enemyIndex];
                
                // ì™„ì „í•œ ì‚¬ê°í˜• ì°¾ê¸°
                const rectangle = findEnemyRectangle(enemy);
                if (rectangle) {
                    console.log('ğŸ’¥ ì™„ì „í•œ ì‚¬ê°í˜• í­ë°œ!', `${rectangle.width}x${rectangle.height}`, `ì êµ° ì¸ë±ìŠ¤: ${enemyIndex}`);
                    explodeIndividualEnemy(enemyIndex, rectangle);
                    explosionOccurred = true;
                    break; // í•œ ë²ˆì— í•˜ë‚˜ì”©ë§Œ í­ë°œ
                }
            }
            
            return explosionOccurred;
        }
        


        // ê°œë³„ ì êµ°ê³¼ ë¶™ì€ ì´ì•Œë“¤ì´ ì‚¬ê°í˜•ì„ ì´ë£¨ëŠ”ì§€ í™•ì¸
        function findEnemyRectangle(enemy) {
            // ì êµ°ì˜ ëª¨ë“  ë¸”ë¡ ìœ„ì¹˜ ìˆ˜ì§‘
            const enemyBlocks = [];
            for (let row = 0; row < enemy.shape.length; row++) {
                for (let col = 0; col < enemy.shape[row].length; col++) {
                    if (enemy.shape[row][col] === 1) {
                        enemyBlocks.push({
                            x: enemy.x + col,
                            y: enemy.y + row
                        });
                    }
                }
            }
            
            // ë¶™ì€ ì´ì•Œ ìœ„ì¹˜ ìˆ˜ì§‘
            const bulletBlocks = enemy.attachedBullets.map(bullet => ({
                x: enemy.x + bullet.relativeX,
                y: enemy.y + bullet.relativeY
            }));
            
            // ì „ì²´ ë¸”ë¡ ìœ„ì¹˜ (ì êµ° + ì´ì•Œ)
            const allBlocks = [...enemyBlocks, ...bulletBlocks];
            
            console.log('ğŸ” ì‚¬ê°í˜• ì²´í¬:', 'ì êµ° ë¸”ë¡:', enemyBlocks.length, 'ì´ì•Œ ë¸”ë¡:', bulletBlocks.length, 'ì´ ë¸”ë¡:', allBlocks.length);
            
            // ìµœì†Œ ë¸”ë¡ ìˆ˜ ì²´í¬ë¥¼ ì™„í™” (1ê°œ ë¸”ë¡ë„ ê°€ëŠ¥)
            if (allBlocks.length < 1) return null; // ìµœì†Œ 1ê°œ ë¸”ë¡ í•„ìš”
            
            // ê²½ê³„ ë°•ìŠ¤ ê³„ì‚°
            const minX = Math.min(...allBlocks.map(block => block.x));
            const maxX = Math.max(...allBlocks.map(block => block.x));
            const minY = Math.min(...allBlocks.map(block => block.y));
            const maxY = Math.max(...allBlocks.map(block => block.y));
            
            const width = maxX - minX + 1;
            const height = maxY - minY + 1;
            
            console.log('ğŸ“ ê²½ê³„ ë°•ìŠ¤:', `${width}x${height}`, `ìœ„ì¹˜: (${minX}, ${minY})`);
            
            // ë©´ì ì´ ìµœì†Œ 1 ì´ìƒì´ì–´ì•¼ í•¨ (1x1, 1x2, 2x1, 2x2 ë“±)
            if (width * height < 1) return null;
            
            // 1x1ë„ í—ˆìš© (ë‹¨ì¼ ë¸”ë¡ë„ ì œê±° ê°€ëŠ¥)
            // if (width === 1 && height === 1) return null;
            
            // í­ë°œ ì¡°ê±´ í™•ì¸
            const area = width * height;
            const blockCount = allBlocks.length;
            
            console.log('ğŸ¯ í­ë°œ ì¡°ê±´ ì²´í¬:', 'ë©´ì :', area, 'ë¸”ë¡ ìˆ˜:', blockCount, 'ì êµ°:', enemyBlocks.length, 'ì´ì•Œ:', bulletBlocks.length);
            
            // íŠ¹ë³„ ì¡°ê±´: ì êµ°ì— ì´ì•Œì´ ë¶™ìœ¼ë©´ í­ë°œ (1ê°œ ë¸”ë¡ë¶€í„° ê°€ëŠ¥)
            if (bulletBlocks.length > 0) {
                // ë©´ì ì´ 1 ì´ìƒì´ê³  ì™„ì „íˆ ì±„ì›Œì§„ ì§ì‚¬ê°í˜•ì´ë©´ í­ë°œ
                if (area >= 1 && blockCount === area) {
                    console.log('âœ… ì§ì‚¬ê°í˜• ì¡°ê±´ ë§Œì¡±: ë©´ì ', area, '= ë¸”ë¡ ìˆ˜', blockCount);
                    // ì¶”ê°€ ì¡°ê±´ ì—†ì´ í­ë°œ
                } else {
                    console.log('âŒ ì§ì‚¬ê°í˜• ì¡°ê±´ ë¶ˆë§Œì¡±: ë©´ì ', area, 'â‰  ë¸”ë¡ ìˆ˜', blockCount);
                    return null;
                }
            } else {
                // ì´ì•Œì´ ì—†ìœ¼ë©´ ì êµ°ë§Œìœ¼ë¡œëŠ” í­ë°œí•˜ì§€ ì•ŠìŒ (ì›ë˜ ê·œì¹™)
                console.log('âŒ ì´ì•Œì´ ì—†ì–´ì„œ í­ë°œí•˜ì§€ ì•ŠìŒ');
                return null;
            }
            
            // ê²½ê³„ ë°•ìŠ¤ ë‚´ì˜ ëª¨ë“  ì¹¸ì´ ë¸”ë¡ìœ¼ë¡œ ì±„ì›Œì ¸ ìˆëŠ”ì§€ í™•ì¸
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    const hasBlock = allBlocks.some(block => block.x === x && block.y === y);
                    if (!hasBlock) {
                        console.log('âŒ ë¹ˆ ì¹¸ ë°œê²¬:', `(${x}, ${y})`);
                        return null; // ë¹ˆ ì¹¸ì´ ìˆìœ¼ë©´ ì‚¬ê°í˜•ì´ ì•„ë‹˜
                    }
                }
            }
            
            console.log('âœ… ì™„ì „í•œ ì‚¬ê°í˜• ë°œê²¬!', `${width}x${height}`);
            
            // ì™„ì „í•œ ì‚¬ê°í˜•ì„ì„ í™•ì¸
            return {
                x: minX,
                y: minY,
                width: width,
                height: height,
                enemyBlocks: enemyBlocks,
                bulletBlocks: bulletBlocks
            };
        }
        


        // ê°œë³„ ì êµ° í­ë°œ ì²˜ë¦¬
        function explodeIndividualEnemy(enemyIndex, rectangle) {
            // ì ìˆ˜ ê³„ì‚°: ì‚¬ê°í˜• ë©´ì  = ì´ì•Œ í¬ê¸°ë¡œ ê³„ì‚°
            const rectangleArea = rectangle.width * rectangle.height;
            const bulletCount = rectangle.bulletBlocks.length;
            const totalScore = rectangleArea; // ì´ì•Œ ì‚¬ì´ì¦ˆ = 1ì ì´ë¯€ë¡œ ë©´ì ì´ ê³§ ì ìˆ˜
            
            // ì ìˆ˜ ëˆ„ì 
            score += totalScore;
            console.log('ğŸ¯ ì ìˆ˜ íšë“!', `ë©´ì : ${rectangleArea}`, `ì´ì•Œ: ${bulletCount}ê°œ`, `ì ìˆ˜: +${totalScore}`, `ì´ì : ${score}`);
            
            // í­ë°œ íŒŒí‹°í´ ìƒì„±
            for (let y = rectangle.y; y < rectangle.y + rectangle.height; y++) {
                for (let x = rectangle.x; x < rectangle.x + rectangle.width; x++) {
                    for (let i = 0; i < 4; i++) {
                        explosionParticles.push({
                            x: (x + Math.random()) * GRID,
                            y: (y + Math.random()) * GRID,
                            vx: (Math.random() - 0.5) * 6,
                            vy: (Math.random() - 0.5) * 6 - 2,
                            life: 30,
                            maxLife: 30,
                            size: 2 + Math.random() * 3
                        });
                    }
                }
            }
            
            // í•´ë‹¹ ì êµ° ì™„ì „ ì œê±°
            enemies.splice(enemyIndex, 1);
            
            // ê³ ì •ëœ ë¸”ë¡ë“¤ ì¤‘ í­ë°œ ì˜ì—­ì— ìˆëŠ” ê²ƒë“¤ ì œê±°
            for (let y = rectangle.y; y < rectangle.y + rectangle.height; y++) {
                for (let x = rectangle.x; x < rectangle.x + rectangle.width; x++) {
                    if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
                        // í•´ë‹¹ ìœ„ì¹˜ê°€ ë°©ê¸ˆ í­ë°œí•œ ì êµ°ì˜ ì¼ë¶€ì˜€ë‹¤ë©´ ì œê±°
                        const wasEnemyBlock = rectangle.enemyBlocks.some(block => block.x === x && block.y === y);
                        const wasBulletBlock = rectangle.bulletBlocks.some(block => block.x === x && block.y === y);
                        
                        if (wasEnemyBlock || wasBulletBlock) {
                            // ê²Œì„ í•„ë“œì— ê³ ì •ëœ ë¸”ë¡ì€ ì œê±°í•˜ì§€ ì•ŠìŒ (ë–¨ì–´ì§€ëŠ” ì¤‘ì¸ ì êµ°ë§Œ ì œê±°)
                            // gameField[y][x] = 0;
                        }
                    }
                }
            }
        }
        
        // ì„ì‹œ ì‚¬ê°í˜• í­ë°œ ì²˜ë¦¬ (ë–¨ì–´ì§€ëŠ” ì ë“¤ê³¼ ë¶™ì€ ì´ì•Œë“¤ ì²˜ë¦¬)
        function explodeTemporaryRectangle(rectangle) {
            // í­ë°œ íŒŒí‹°í´ ìƒì„±
            for (let y = rectangle.y; y < rectangle.y + rectangle.height; y++) {
                for (let x = rectangle.x; x < rectangle.x + rectangle.width; x++) {
                    for (let i = 0; i < 4; i++) {
                        explosionParticles.push({
                            x: (x + Math.random()) * GRID,
                            y: (y + Math.random()) * GRID,
                            vx: (Math.random() - 0.5) * 6,
                            vy: (Math.random() - 0.5) * 6 - 2,
                            life: 30,
                            maxLife: 30,
                            size: 2 + Math.random() * 3
                        });
                    }
                }
            }
            
            // í­ë°œ ì˜ì—­ì— í•´ë‹¹í•˜ëŠ” ë–¨ì–´ì§€ëŠ” ì ë“¤ê³¼ ë¶™ì€ ì´ì•Œë“¤ ì œê±°
            for (let enemyIndex = enemies.length - 1; enemyIndex >= 0; enemyIndex--) {
                const enemy = enemies[enemyIndex];
                let enemyInExplosion = false;
                
                // ì  ë¸”ë¡ì´ í­ë°œ ì˜ì—­ì— ìˆëŠ”ì§€ í™•ì¸
                for (let row = 0; row < enemy.shape.length; row++) {
                    for (let col = 0; col < enemy.shape[row].length; col++) {
                        if (enemy.shape[row][col] === 1) {
                            const x = enemy.x + col;
                            const y = enemy.y + row;
                            if (x >= rectangle.x && x < rectangle.x + rectangle.width &&
                                y >= rectangle.y && y < rectangle.y + rectangle.height) {
                                enemy.shape[row][col] = 0; // í•´ë‹¹ ë¶€ë¶„ ì œê±°
                                enemyInExplosion = true;
                            }
                        }
                    }
                }
                
                // ë¶™ì€ ì´ì•Œì´ í­ë°œ ì˜ì—­ì— ìˆëŠ”ì§€ í™•ì¸
                for (let bulletIndex = enemy.attachedBullets.length - 1; bulletIndex >= 0; bulletIndex--) {
                    const attachedBullet = enemy.attachedBullets[bulletIndex];
                    const bulletX = enemy.x + attachedBullet.relativeX;
                    const bulletY = enemy.y + attachedBullet.relativeY;
                    if (bulletX >= rectangle.x && bulletX < rectangle.x + rectangle.width &&
                        bulletY >= rectangle.y && bulletY < rectangle.y + rectangle.height) {
                        enemy.attachedBullets.splice(bulletIndex, 1); // ë¶™ì€ ì´ì•Œ ì œê±°
                        enemyInExplosion = true;
                    }
                }
                
                // ì ì´ ì™„ì „íˆ ë¹„ì–´ìˆìœ¼ë©´ ì œê±°
                if (enemyInExplosion) {
                    let enemyEmpty = true;
                    for (let r = 0; r < enemy.shape.length; r++) {
                        for (let c = 0; c < enemy.shape[r].length; c++) {
                            if (enemy.shape[r][c] === 1) {
                                enemyEmpty = false;
                                break;
                            }
                        }
                        if (!enemyEmpty) break;
                    }
                    
                    if (enemyEmpty && enemy.attachedBullets.length === 0) {
                        enemies.splice(enemyIndex, 1);
                    }
                }
            }
            
            // ê³ ì •ëœ ë¸”ë¡ë“¤ë„ ì œê±°
            for (let y = rectangle.y; y < rectangle.y + rectangle.height; y++) {
                for (let x = rectangle.x; x < rectangle.x + rectangle.width; x++) {
                    if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
                        gameField[y][x] = 0;
                    }
                }
            }
        }

        // ì¶©ëŒ ê°ì§€
        function checkCollisions() {
            for (let bulletIndex = bullets.length - 1; bulletIndex >= 0; bulletIndex--) {
                const bullet = bullets[bulletIndex];
                let bulletHit = false;

                // ë–¨ì–´ì§€ëŠ” ì ê³¼ ì¶©ëŒ ë¨¼ì € ì²´í¬ (ìš°ì„ ìˆœìœ„ê°€ ë†’ìŒ)
                for (let enemyIndex = 0; enemyIndex < enemies.length; enemyIndex++) {
                    const enemy = enemies[enemyIndex];

                    // 1. ì ì˜ í•‘í¬ìƒ‰ ë¸”ë¡ê³¼ ì¶©ëŒ ì²´í¬
                    for (let row = 0; row < enemy.shape.length; row++) {
                        for (let col = 0; col < enemy.shape[row].length; col++) {
                            if (enemy.shape[row][col] === 1) {
                                const enemyX = enemy.x + col;
                                const enemyY = enemy.y + row;

                                // ì´ì•Œì´ ì  ë¸”ë¡ê³¼ ì¶©ëŒí–ˆëŠ”ì§€ ì²´í¬ (ì„œë¡œ ì§€ë‚˜ê°€ëŠ” ê²½ìš°ë„ ê°ì§€)
                                const enemyPrevY = enemy.prevY !== undefined ? enemy.prevY : enemyY;
                                if (bullet.x === enemyX && 
                                    (bullet.y === enemyY || 
                                     (bullet.prevY !== undefined && 
                                      ((bullet.prevY <= enemyY && bullet.y >= enemyPrevY) ||
                                       (bullet.prevY >= enemyPrevY && bullet.y <= enemyY))))) {
                                    
                                    // ì´ì•Œì„ ì  ë¸”ë¡ ë°”ë¡œ ì•„ë˜ì— ë¶™ì´ê¸° (ì›ë˜ ë¡œì§)
                                    const relativeX = col;
                                    const relativeY = row + 1; // ì  ë¸”ë¡ ë°”ë¡œ ì•„ë˜
                                    
                                    // ì´ë¯¸ ê°™ì€ ìœ„ì¹˜ì— ë¶™ì€ ì´ì•Œì´ ì—†ëŠ”ì§€ í™•ì¸
                                    const alreadyAttached = enemy.attachedBullets.some(
                                        attached => attached.relativeX === relativeX && attached.relativeY === relativeY
                                    );
                                    
                                    if (!alreadyAttached) {
                                        enemy.attachedBullets.push({
                                            relativeX: relativeX,
                                            relativeY: relativeY
                                        });
                                        console.log('ğŸ’¥ ì¶©ëŒ! ì´ì•Œì´ ì  ë¸”ë¡ ì•„ë˜ì— ë¶™ìŒ:', relativeX, relativeY);
                                        
                                        // ì´ì•Œì´ ë¶™ì€ ì¦‰ì‹œ ê°œë³„ ì êµ° ì‚¬ê°í˜• ì²´í¬
                                        if (checkIndividualEnemyRectangles()) {
                                            // í­ë°œì´ ë°œìƒí–ˆìœ¼ë¯€ë¡œ ë” ì´ìƒ ì²˜ë¦¬í•  í•„ìš” ì—†ìŒ
                                            bullets.splice(bulletIndex, 1);
                                            return; // ì¶©ëŒ ê°ì§€ í•¨ìˆ˜ ì¢…ë£Œ
                                        }
                                    }

                                    bullets.splice(bulletIndex, 1);
                                    bulletHit = true;
                                    break;
                                }
                            }
                        }
                        if (bulletHit) break;
                    }

                    // 2. ë¶™ì–´ìˆëŠ” ì´ì•Œë“¤ê³¼ ì¶©ëŒ ì²´í¬
                    if (!bulletHit) {
                        for (let attachedIndex = 0; attachedIndex < enemy.attachedBullets.length; attachedIndex++) {
                            const attachedBullet = enemy.attachedBullets[attachedIndex];
                            const attachedX = enemy.x + attachedBullet.relativeX;
                            const attachedY = enemy.y + attachedBullet.relativeY;

                            // ì´ì•Œì´ ë¶™ì–´ìˆëŠ” ì´ì•Œê³¼ ì¶©ëŒí–ˆëŠ”ì§€ ì²´í¬ (ì„œë¡œ ì§€ë‚˜ê°€ëŠ” ê²½ìš°ë„ ê°ì§€)
                            const attachedPrevY = enemy.prevY !== undefined ? enemy.prevY + attachedBullet.relativeY : attachedY;
                            if (bullet.x === attachedX && 
                                (bullet.y === attachedY || 
                                 (bullet.prevY !== undefined && 
                                  ((bullet.prevY <= attachedY && bullet.y >= attachedPrevY) ||
                                   (bullet.prevY >= attachedPrevY && bullet.y <= attachedY))))) {
                                
                                // ë¶™ì–´ìˆëŠ” ì´ì•Œ ë°”ë¡œ ì•„ë˜ì— ìƒˆ ì´ì•Œ ë¶™ì´ê¸° (ì›ë˜ ë¡œì§)
                                const newRelativeX = attachedBullet.relativeX;
                                const newRelativeY = attachedBullet.relativeY + 1; // ë¶™ì–´ìˆëŠ” ì´ì•Œ ë°”ë¡œ ì•„ë˜
                                
                                // ì´ë¯¸ ê°™ì€ ìœ„ì¹˜ì— ë¶™ì€ ì´ì•Œì´ ì—†ëŠ”ì§€ í™•ì¸
                                const alreadyAttached = enemy.attachedBullets.some(
                                    attached => attached.relativeX === newRelativeX && attached.relativeY === newRelativeY
                                );
                                
                                if (!alreadyAttached) {
                                    enemy.attachedBullets.push({
                                        relativeX: newRelativeX,
                                        relativeY: newRelativeY
                                    });
                                    console.log('ğŸ’¥ ì¶©ëŒ! ì´ì•Œì´ ë¶™ì€ ì´ì•Œ ì•„ë˜ì— ë¶™ìŒ:', newRelativeX, newRelativeY);
                                    
                                    // ì´ì•Œì´ ë¶™ì€ ì¦‰ì‹œ ê°œë³„ ì êµ° ì‚¬ê°í˜• ì²´í¬
                                    if (checkIndividualEnemyRectangles()) {
                                        // í­ë°œì´ ë°œìƒí–ˆìœ¼ë¯€ë¡œ ë” ì´ìƒ ì²˜ë¦¬í•  í•„ìš” ì—†ìŒ
                                        bullets.splice(bulletIndex, 1);
                                        return; // ì¶©ëŒ ê°ì§€ í•¨ìˆ˜ ì¢…ë£Œ
                                    }
                                }

                                bullets.splice(bulletIndex, 1);
                                bulletHit = true;
                                break;
                            }
                        }
                    }
                    
                    if (bulletHit) break;
                }

                // ë–¨ì–´ì§€ëŠ” ì ê³¼ ì¶©ëŒí•˜ì§€ ì•Šì€ ê²½ìš°ì—ë§Œ ë‹¤ë¥¸ ì¶©ëŒ ì²´í¬
                if (!bulletHit) {
                    // ë°”ë‹¥ì— ë‹¿ìœ¼ë©´ ë…¸ë€ìƒ‰ ë¸”ë¡ìœ¼ë¡œ ë³€í™˜
                    if (bullet.y >= ROWS - 1) {
                        if (bullet.x >= 0 && bullet.x < COLS) {
                            gameField[ROWS - 1][bullet.x] = 2;
                        }
                        bullets.splice(bulletIndex, 1);
                        console.log('ğŸ’› ì´ì•Œì´ ë°”ë‹¥ì— ì°©ì§€');
                        continue;
                    }

                    // ì´ë¯¸ ìŒ“ì¸ ë¸”ë¡ê³¼ ì¶©ëŒ
                    if (bullet.y >= 0 && bullet.y < ROWS && bullet.x >= 0 && bullet.x < COLS) {
                        if (gameField[bullet.y][bullet.x] !== 0) {
                            if (bullet.y - 1 >= 0) {
                                gameField[bullet.y - 1][bullet.x] = 2;
                            }
                            bullets.splice(bulletIndex, 1);
                            console.log('ğŸ’› ì´ì•Œì´ ë¸”ë¡ ìœ„ì— ì°©ì§€');
                            continue;
                        }
                    }
                }
            }
        }

        // ì‚¬ê°í˜• ê°ì§€ ë° í­ë°œ ì‹œìŠ¤í…œ (ê°œì„ ëœ ë²„ì „)
        function checkRectangles() {
            const toRemove = [];
            
            // ëª¨ë“  ê°€ëŠ¥í•œ ì‚¬ê°í˜• í¬ê¸°ë¥¼ ì²´í¬ (2x2ë¶€í„° ì‹œì‘)
            for (let height = 2; height <= Math.min(ROWS, 5); height++) {
                for (let width = 2; width <= Math.min(COLS, 5); width++) {
                    for (let y = 0; y <= ROWS - height; y++) {
                        for (let x = 0; x <= COLS - width; x++) {
                            if (isValidRectangle(x, y, width, height)) {
                                // ì¤‘ë³µ ì œê±°ë¥¼ ìœ„í•´ ë°°ì—´ì— ì¶”ê°€
                                const rect = { x, y, width, height };
                                if (!isOverlapping(rect, toRemove)) {
                                    toRemove.push(rect);
                                    console.log('ğŸ” ì‚¬ê°í˜• ë°œê²¬!', `${width}x${height}`, `ìœ„ì¹˜: (${x}, ${y})`);
                                }
                            }
                        }
                    }
                }
            }
            
            // ê°€ì¥ í° ì‚¬ê°í˜•ë¶€í„° í­ë°œ (ê²¹ì¹˜ëŠ” ê²ƒ ë°©ì§€)
            toRemove.sort((a, b) => (b.width * b.height) - (a.width * a.height));
            
            const exploded = [];
            for (const rect of toRemove) {
                if (!isRectangleExploded(rect, exploded)) {
                    explodeRectangle(rect);
                    exploded.push(rect);
                }
            }
            
            if (toRemove.length > 0) {
                console.log('ğŸ“Š ê°ì§€ëœ ì‚¬ê°í˜• ì´', toRemove.length, 'ê°œ, í­ë°œ ì²˜ë¦¬:', exploded.length, 'ê°œ');
            }
        }
        
        // íŠ¹ì • ìœ„ì¹˜ì™€ í¬ê¸°ê°€ ì™„ì „í•œ ì‚¬ê°í˜•ì¸ì§€ í™•ì¸
        function isValidRectangle(startX, startY, width, height) {
            // ê²½ê³„ ì²´í¬
            if (startX + width > COLS || startY + height > ROWS) {
                return false;
            }
            
            // ëª¨ë“  ì¹¸ì´ ì±„ì›Œì ¸ ìˆëŠ”ì§€ í™•ì¸
            for (let y = startY; y < startY + height; y++) {
                for (let x = startX; x < startX + width; x++) {
                    if (gameField[y][x] === 0) {
                        return false;
                    }
                }
            }
            
            return true;
        }
        
        // ë””ë²„ê·¸: ê²Œì„ í•„ë“œ ìƒíƒœ ì¶œë ¥
        function debugGameField() {
            console.log('ğŸ® ê²Œì„ í•„ë“œ ìƒíƒœ:');
            for (let y = 0; y < ROWS; y++) {
                let row = '';
                for (let x = 0; x < COLS; x++) {
                    if (gameField[y][x] === 0) row += 'â¬›';
                    else if (gameField[y][x] === 1) row += 'ğŸŸª';
                    else if (gameField[y][x] === 2) row += 'ğŸŸ¨';
                }
                if (row.includes('ğŸŸª') || row.includes('ğŸŸ¨')) {
                    console.log(`Row ${y}: ${row}`);
                }
            }
            
            // ë–¨ì–´ì§€ëŠ” ì êµ°ë“¤ ìƒíƒœ ì¶œë ¥
            console.log('ğŸ‘¾ ë–¨ì–´ì§€ëŠ” ì êµ°ë“¤:');
            enemies.forEach((enemy, index) => {
                console.log(`ì êµ° ${index}: ìœ„ì¹˜(${enemy.x}, ${enemy.y}), ë¶™ì€ ì´ì•Œ: ${enemy.attachedBullets.length}ê°œ`);
                console.log('ì êµ° ëª¨ì–‘:');
                for (let row = 0; row < enemy.shape.length; row++) {
                    let shapeRow = '';
                    for (let col = 0; col < enemy.shape[row].length; col++) {
                        shapeRow += enemy.shape[row][col] === 1 ? 'ğŸŸª' : 'â¬›';
                    }
                    console.log(`  ${shapeRow}`);
                }
                if (enemy.attachedBullets.length > 0) {
                    console.log('ë¶™ì€ ì´ì•Œ ìœ„ì¹˜:');
                    enemy.attachedBullets.forEach((bullet, bulletIndex) => {
                        const absX = enemy.x + bullet.relativeX;
                        const absY = enemy.y + bullet.relativeY;
                        console.log(`  ì´ì•Œ ${bulletIndex}: ìƒëŒ€ìœ„ì¹˜(${bullet.relativeX}, ${bullet.relativeY}) = ì ˆëŒ€ìœ„ì¹˜(${absX}, ${absY})`);
                    });
                }
                console.log('---');
            });
        }
        
        // ì‚¬ê°í˜•ì´ ë‹¤ë¥¸ ì‚¬ê°í˜•ë“¤ê³¼ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸
        function isOverlapping(rect, rectList) {
            return rectList.some(other => 
                rect.x < other.x + other.width &&
                rect.x + rect.width > other.x &&
                rect.y < other.y + other.height &&
                rect.y + rect.height > other.y
            );
        }
        
        // ì‚¬ê°í˜•ì´ ì´ë¯¸ í­ë°œí•œ ì˜ì—­ì— í¬í•¨ë˜ëŠ”ì§€ í™•ì¸
        function isRectangleExploded(rect, exploded) {
            return exploded.some(other =>
                rect.x >= other.x &&
                rect.y >= other.y &&
                rect.x + rect.width <= other.x + other.width &&
                rect.y + rect.height <= other.y + other.height
            );
        }
        
        // ì‚¬ê°í˜• í­ë°œ ì²˜ë¦¬
        function explodeRectangle(rectangle) {
            console.log('ğŸ’¥ ì‚¬ê°í˜• í­ë°œ!', `${rectangle.width}x${rectangle.height}`, `ìœ„ì¹˜: (${rectangle.x}, ${rectangle.y})`);
            
            // í­ë°œ íŒŒí‹°í´ ìƒì„±
            for (let y = rectangle.y; y < rectangle.y + rectangle.height; y++) {
                for (let x = rectangle.x; x < rectangle.x + rectangle.width; x++) {
                    // ê° ë¸”ë¡ë§ˆë‹¤ ì—¬ëŸ¬ ê°œì˜ ì‘ì€ íŒŒí‹°í´ ìƒì„±
                    for (let i = 0; i < 4; i++) {
                        explosionParticles.push({
                            x: (x + Math.random()) * GRID,
                            y: (y + Math.random()) * GRID,
                            vx: (Math.random() - 0.5) * 6,
                            vy: (Math.random() - 0.5) * 6 - 2,
                            life: 30,
                            maxLife: 30,
                            size: 2 + Math.random() * 3
                        });
                    }
                    
                    // ê²Œì„ í•„ë“œì—ì„œ ë¸”ë¡ ì œê±°
                    gameField[y][x] = 0;
                }
            }
        }
        
        // í­ë°œ íŒŒí‹°í´ ì—…ë°ì´íŠ¸
        function updateExplosionParticles() {
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                const particle = explosionParticles[i];
                
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += 0.2; // ì¤‘ë ¥
                particle.life--;
                
                if (particle.life <= 0) {
                    explosionParticles.splice(i, 1);
                }
            }
        }
        
        // í­ë°œ íŒŒí‹°í´ ê·¸ë¦¬ê¸°
        function drawExplosionParticles() {
            explosionParticles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
                ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
            });
        }

        // ê²Œì„ ì˜¤ë²„ ì²´í¬
        function checkGameOver() {
            if (isGameOver || gameState !== 'playing') return;
            
            // ë–¨ì–´ì§€ëŠ” ì êµ°ë“¤(í•‘í¬ìƒ‰ ë„í˜•)ê³¼ ë¶™ì€ ì´ì•Œë“¤ì´ ë¼ì¸ì— ë‹¿ì•˜ëŠ”ì§€ í™•ì¸
            for (let enemy of enemies) {
                // ì êµ° ë¸”ë¡ ì²´í¬
                for (let row = 0; row < enemy.shape.length; row++) {
                    for (let col = 0; col < enemy.shape[row].length; col++) {
                        if (enemy.shape[row][col] === 1) {
                            const blockY = enemy.y + row;
                            if (blockY >= gameOverLineY) {
                                console.log('ğŸ’€ ê²Œì„ ì˜¤ë²„! ì êµ°ì´ ë¼ì¸ì— ë‹¿ìŒ:', blockY, '>=', gameOverLineY);
                                updateHighScore();
                                isGameOver = true;
                                gameState = 'gameOver';
                                return;
                            }
                        }
                    }
                }
                
                // ì êµ°ì— ë¶™ì€ ì´ì•Œë“¤ ì²´í¬
                for (let attachedBullet of enemy.attachedBullets) {
                    const bulletY = enemy.y + attachedBullet.relativeY;
                    if (bulletY >= gameOverLineY) {
                        console.log('ğŸ’€ ê²Œì„ ì˜¤ë²„! ë¶™ì€ ì´ì•Œì´ ë¼ì¸ì— ë‹¿ìŒ:', bulletY, '>=', gameOverLineY);
                        updateHighScore();
                        isGameOver = true;
                        gameState = 'gameOver';
                        return;
                    }
                }
            }
            
            // ê³ ì •ëœ ë¸”ë¡ë“¤(í•‘í¬ìƒ‰)ë„ ì²´í¬
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (gameField[y][x] === 1 && y >= gameOverLineY) {
                        console.log('ğŸ’€ ê²Œì„ ì˜¤ë²„! ê³ ì •ëœ í•‘í¬ ë¸”ë¡ì´ ë¼ì¸ì— ë‹¿ìŒ:', y, '>=', gameOverLineY);
                        updateHighScore();
                        isGameOver = true;
                        gameState = 'gameOver';
                        return;
                    }
                }
            }
        }

        // ì  ì°©ì§€ ì²´í¬
        function checkEnemyLanding() {
            for (let enemyIndex = enemies.length - 1; enemyIndex >= 0; enemyIndex--) {
                const enemy = enemies[enemyIndex];
                let hasLanded = false;

                for (let row = 0; row < enemy.shape.length; row++) {
                    for (let col = 0; col < enemy.shape[row].length; col++) {
                        if (enemy.shape[row][col] === 1) {
                            const x = enemy.x + col;
                            const y = enemy.y + row;

                            // ë°”ìš´ë”ë¦¬ ì²´í¬ ì¶”ê°€
                            if (x >= 0 && x < COLS && y >= 0) {
                                // ë°”ë‹¥ì— ë‹¿ì•˜ê±°ë‚˜, í•‘í¬ìƒ‰ ë¸”ë¡(1) ìœ„ì— ìˆì„ ë•Œë§Œ ì°©ì§€ë¡œ íŒë‹¨
                                // ë…¸ë€ìƒ‰ ë¸”ë¡(2)ì€ ì´ì•Œì´ ë¶™ì€ ê²ƒì´ë¯€ë¡œ ë¬´ì‹œ
                                if (y >= ROWS - 1 || (y + 1 < ROWS && gameField[y + 1][x] === 1)) {
                                    hasLanded = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (hasLanded) break;
                }

                if (hasLanded) {
                    // ì ì„ ê²Œì„ í•„ë“œì— ê³ ì •
                    for (let row = 0; row < enemy.shape.length; row++) {
                        for (let col = 0; col < enemy.shape[row].length; col++) {
                            if (enemy.shape[row][col] === 1) {
                                const x = enemy.x + col;
                                const y = enemy.y + row;
                                if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
                                    gameField[y][x] = 1; // í•‘í¬ìƒ‰ ë¸”ë¡ìœ¼ë¡œ ê³ ì •
                                }
                            }
                        }
                    }
                    
                    // ë¶™ì€ ì´ì•Œë“¤ë„ ê²Œì„ í•„ë“œì— ê³ ì •
                    enemy.attachedBullets.forEach(attachedBullet => {
                        const bulletX = enemy.x + attachedBullet.relativeX;
                        const bulletY = enemy.y + attachedBullet.relativeY;
                        if (bulletY >= 0 && bulletY < ROWS && bulletX >= 0 && bulletX < COLS) {
                            gameField[bulletY][bulletX] = 2; // ë…¸ë€ìƒ‰ ë¸”ë¡ìœ¼ë¡œ ê³ ì •
                        }
                    });

                    enemies.splice(enemyIndex, 1);
                    console.log('ğŸ”» í•‘í¬ìƒ‰ ë¸”ë¡ì´ ì°©ì§€í•˜ì—¬ ê³ ì •ë¨ (ë¶™ì€ ì´ì•Œ:', enemy.attachedBullets.length, 'ê°œ)');
                }
            }
        }

        // ê²Œì„ í•„ë“œ ê·¸ë¦¬ê¸°
        function drawGameField() {
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (gameField[y][x] === 1) {
                        ctx.fillStyle = '#ff69b4'; // í•‘í¬ìƒ‰
                        ctx.fillRect(x * GRID, y * GRID, GRID, GRID);
                    } else if (gameField[y][x] === 2) {
                        ctx.fillStyle = '#ffff00'; // ë…¸ë€ìƒ‰
                        ctx.fillRect(x * GRID, y * GRID, GRID, GRID);
                    }
                }
            }
        }

        // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
        function drawPlayer() {
            ctx.fillStyle = '#0f0';
            // ìœ„ìª½ ëŒê¸°
            ctx.fillRect((player.x + 1) * GRID, player.y * GRID, GRID, GRID);
            // ì•„ë˜ìª½ ê°€ë¡œë§‰ëŒ€
            ctx.fillRect(player.x * GRID, (player.y + 1) * GRID, 3 * GRID, GRID);
        }

        // ì´ì•Œ ê·¸ë¦¬ê¸°
        function drawBullets() {
            ctx.fillStyle = '#ffff00';
            bullets.forEach(bullet => {
                ctx.fillRect(bullet.x * GRID, bullet.y * GRID, GRID, GRID);
            });
        }

        // ì  ê·¸ë¦¬ê¸°
        function drawEnemies() {
            enemies.forEach(enemy => {
                // í•‘í¬ìƒ‰ ì  ë¸”ë¡ ê·¸ë¦¬ê¸°
                ctx.fillStyle = '#ff69b4';
                for (let row = 0; row < enemy.shape.length; row++) {
                    for (let col = 0; col < enemy.shape[row].length; col++) {
                        if (enemy.shape[row][col] === 1) {
                            ctx.fillRect((enemy.x + col) * GRID, (enemy.y + row) * GRID, GRID, GRID);
                        }
                    }
                }
                
                // ë¶™ì€ ì´ì•Œë“¤ ê·¸ë¦¬ê¸°
                ctx.fillStyle = '#ffff00';
                enemy.attachedBullets.forEach(attachedBullet => {
                    const bulletX = enemy.x + attachedBullet.relativeX;
                    const bulletY = enemy.y + attachedBullet.relativeY;
                    if (bulletY >= 0 && bulletY < ROWS && bulletX >= 0 && bulletX < COLS) {
                        ctx.fillRect(bulletX * GRID, bulletY * GRID, GRID, GRID);
                    }
                });
            });
        }

        // ê²Œì„ í”„ë ˆì„ ì¹´ìš´í„°
        let gameFrame = 0;

        // ê²Œì„ ì—…ë°ì´íŠ¸
        function update() {
            // ê²Œì„ í”Œë ˆì´ ì¤‘ì´ ì•„ë‹ˆê±°ë‚˜ ê²Œì„ ì˜¤ë²„ ìƒíƒœì—ì„œëŠ” ì—…ë°ì´íŠ¸ ì¤‘ë‹¨
            if (gameState !== 'playing' || isGameOver) return;
            
            gameFrame++;
            
            updatePlayer();
            
            // ì´ì•Œ ì´ë™ í›„ ì¦‰ì‹œ ì¶©ëŒ ì²´í¬
            updateBullets();
            checkCollisions();
            
            // ì êµ° ì´ë™ í›„ ë‹¤ì‹œ ì¶©ëŒ ì²´í¬
            updateEnemies();
            checkCollisions();
            
            checkEnemyLanding();
            
            // ê²Œì„ ì˜¤ë²„ ì²´í¬ (ì êµ°ê³¼ ë¸”ë¡ì´ ë¼ì¸ì— ë‹¿ì•˜ëŠ”ì§€ í™•ì¸)
            checkGameOver();
            
            // ê°œë³„ ì êµ° ì‚¬ê°í˜• ê°ì§€ ë° í­ë°œ
            checkIndividualEnemyRectangles();
            
            // í­ë°œ íŒŒí‹°í´ ì—…ë°ì´íŠ¸
            updateExplosionParticles();
            
            // 120í”„ë ˆì„ë§ˆë‹¤ ë„í˜• ìƒì„± (ì•½ 2ì´ˆ)
            if (gameFrame % 120 === 0) {
                spawnEnemy();
            }
        }

        // ì ìˆ˜ í‘œì‹œ ê·¸ë¦¬ê¸°
        function drawScore() {
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';
            
            // ìš°ì¸¡ ìƒë‹¨ì— í˜„ì¬ ì ìˆ˜ í‘œì‹œ (ì˜¤ë¥¸ìª½ ì—¬ë°± 20px, ìœ„ìª½ ì—¬ë°± 20px)
            ctx.fillText(`ì ìˆ˜: ${score}`, canvas.width - 20, 20);
            
            // í…ìŠ¤íŠ¸ ì •ë ¬ ì›ìƒë³µêµ¬
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
        }

        // ìµœê³  ì ìˆ˜ í‘œì‹œ ê·¸ë¦¬ê¸°
        function drawHighScore() {
            ctx.fillStyle = '#ffff00'; // ë…¸ë€ìƒ‰ìœ¼ë¡œ êµ¬ë¶„
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            
            // ì¢Œì¸¡ ìƒë‹¨ì— ìµœê³  ì ìˆ˜ í‘œì‹œ (ì™¼ìª½ ì—¬ë°± 20px, ìœ„ìª½ ì—¬ë°± 20px)
            ctx.fillText(`ìµœê³  ì ìˆ˜: ${highScore}`, 20, 20);
            
            // í…ìŠ¤íŠ¸ ì •ë ¬ ì›ìƒë³µêµ¬
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
        }

        // ê²Œì„ ì˜¤ë²„ ë¼ì¸ ê·¸ë¦¬ê¸°
        function drawGameOverLine() {
            ctx.strokeStyle = '#ff0000'; // ë¹¨ê°„ìƒ‰ ë¼ì¸
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, gameOverLineY * GRID);
            ctx.lineTo(canvas.width, gameOverLineY * GRID);
            ctx.stroke();
        }

        // ì‹œì‘ í™”ë©´ ê·¸ë¦¬ê¸°
        function drawStartScreen() {
            if (gameState !== 'start') return;
            
            // ê²€ì€ìƒ‰ ë°°ê²½
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ê²Œì„ ì œëª©
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ì‚¬ê°í˜• ë””íœìŠ¤', canvas.width / 2, canvas.height / 2 - 120);
            
            // ê²Œì„ ì„¤ëª…
            ctx.font = '20px Arial';
            ctx.fillText('ì´ì•Œì„ ë°œì‚¬í•´ ì‚¬ê°í˜•ì„ ë§Œë“¤ì–´', canvas.width / 2, canvas.height / 2 - 40);
            ctx.fillText('ì êµ°ì„ ë¬¼ë¦¬ì¹˜ì„¸ìš”.', canvas.width / 2, canvas.height / 2 - 10);
            
            // ì¡°ì‘ë²• ì•ˆë‚´
            ctx.font = '16px Arial';
            ctx.fillStyle = '#cccccc';
            ctx.fillText('â† â†’ : ì´ë™', canvas.width / 2, canvas.height / 2 + 40);
            ctx.fillText('ìŠ¤í˜ì´ìŠ¤ : ë°œì‚¬', canvas.width / 2, canvas.height / 2 + 65);
            
            // ìµœê³  ì ìˆ˜ í‘œì‹œ
            if (highScore > 0) {
                ctx.fillStyle = '#ffff00';
                ctx.font = '18px Arial';
                ctx.fillText(`ìµœê³  ì ìˆ˜: ${highScore}`, canvas.width / 2, canvas.height / 2 + 90);
            }
            
            // ì‹œì‘ ë²„íŠ¼ (ê¹œë¹¡ì´ëŠ” íš¨ê³¼)
            const blinkTime = Math.floor(Date.now() / 500) % 2;
            if (blinkTime === 0) {
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 24px Arial';
                ctx.fillText('ìŠ¤í˜ì´ìŠ¤ë°”ë¥¼ ëˆŒëŸ¬ ì‹œì‘!', canvas.width / 2, canvas.height / 2 + 120);
            }
            
            // í…ìŠ¤íŠ¸ ì •ë ¬ ì›ìƒë³µêµ¬
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
        }

        // ê²Œì„ ì˜¤ë²„ í™”ë©´ ê·¸ë¦¬ê¸°
        function drawGameOver() {
            if (!isGameOver) return;
            
            // ë°˜íˆ¬ëª… ê²€ì€ìƒ‰ ì˜¤ë²„ë ˆì´
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ê²Œì„ ì˜¤ë²„ í…ìŠ¤íŠ¸
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 40);
            
            // ìµœì¢… ì ìˆ˜
            ctx.font = 'bold 24px Arial';
            ctx.fillText(`ìµœì¢… ì ìˆ˜: ${score}`, canvas.width / 2, canvas.height / 2 + 20);
            
            // ìµœê³  ì ìˆ˜ ë° ì‹ ê¸°ë¡ í‘œì‹œ
            ctx.font = '20px Arial';
            if (score === highScore && score > 0) {
                ctx.fillStyle = '#ffff00';
                ctx.fillText('ğŸ† ì‹ ê¸°ë¡!', canvas.width / 2, canvas.height / 2 + 50);
                ctx.fillStyle = '#ffffff';
            }
            ctx.fillText(`ìµœê³  ì ìˆ˜: ${highScore}`, canvas.width / 2, canvas.height / 2 + 80);
            
            // ì¬ì‹œì‘ ì•ˆë‚´
            ctx.font = '18px Arial';
            ctx.fillText('Rí‚¤ë¥¼ ëˆŒëŸ¬ ì¬ì‹œì‘', canvas.width / 2, canvas.height / 2 + 110);
            
            // í…ìŠ¤íŠ¸ ì •ë ¬ ì›ìƒë³µêµ¬
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
        }

        // ê²Œì„ ë Œë”ë§
        function draw() {
            // ì‹œì‘ í™”ë©´
            if (gameState === 'start') {
                drawStartScreen();
                return;
            }
            
            // í™”ë©´ ì§€ìš°ê¸°
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ê·¸ë¦¬ê¸° ìˆœì„œ: ê²Œì„í•„ë“œ â†’ í”Œë ˆì´ì–´ â†’ ì´ì•Œ â†’ ì  â†’ í­ë°œ íŒŒí‹°í´ â†’ ê²Œì„ì˜¤ë²„ë¼ì¸ â†’ ì ìˆ˜ â†’ ìµœê³ ì ìˆ˜ â†’ ê²Œì„ì˜¤ë²„í™”ë©´
            drawGameField();
            drawPlayer();
            drawBullets();
            drawEnemies();
            drawExplosionParticles();
            drawGameOverLine();
            drawScore();
            drawHighScore();
            drawGameOver();
        }

        // ë©”ì¸ ê²Œì„ ë£¨í”„
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // ê²Œì„ ì‹œì‘
        console.log('ê²Œì„ ì´ˆê¸°í™” ì™„ë£Œ. í”Œë ˆì´ì–´ ìœ„ì¹˜:', player.x, player.y);
        
        // ì´ˆê¸° ë„í˜• ìƒì„±
        spawnEnemy();
        
        // ê²Œì„ ë£¨í”„ ì‹œì‘
        gameLoop();
    </script>
</body>
</html>
